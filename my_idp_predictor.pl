#!/usr/local/bin/perl

#################################################################################################################
# Description: A perl script that identifies a list of pdb files with both Xray and NMR structures then 		#
# 			   automatically downloads each files from Protein Data Bank (rcsb.org). After successful download, #
# 		       the script will identify the missing residues in the Xray data then correlate the coordinates of #
#			   missing residues in the NMR data.																#
# Author: 	   Isidro C. Medina Jr.																				#
# Date: 	   2013																								#
#################################################################################################################

use Switch;

print "\nWelcome to the intrinsic disorder prediction tool!\n\n What would you like to do? ";
print "\n  [1] Identify pdb structures resolved by both X-Ray and NMR.";
print "\n  [2] Download X-Ray and NMR structures from the Protein Data Bank.";
print "\n  [3] Identify the missing residues using X-Ray data.";
print "\n  [4] Split NMR-style multiple model pdb files into individual models.";
print "\n  [5] Calculate Phi and Psi using the NMR coordinate file (pdb file).";
print "\n  [6] Calculate Circular Variance using Dihedral Angles.";
print "\n\n  Press q if you want to quit.";

print "\n\nSelect: ";
$choice = <STDIN>;  chomp($choice);
  
# Global Variable(s)
$base = "1K19";											# input PDB ID
  
switch ($choice) {
  case '1' { &open_expMethods; }						# Open a list of pdb files resolved by diff exp methods 
  case '2' { print "\nDownloading pdb files..."; &get_web_pdb;  } # Get the pdb file from Protein Data Bank and write it to an external file
  case '3' { &identify_missing_residues; }				# Get the pdb content from a pdb file
  case '4' { &split_nmr_models; }						# Split NMR-style multiple model pdb files into individual models";
  case '5' { &calc_phi_psi; }							# Calculate Phi and Psi using the NMR coordinate file (pdb file).";
  case '6' { &calc_circ_variance; }						# Calculate the Circular Variance using Dihedral Angles."
} print "\n\nThank you for using this tool!\n";

sub open_expMethods {
# source: http://www.pdb.org/pdb/statistics/clusterExpMethods.do
  open (PDBMETH, 'clusterExpMethods.csv');	# Open csv file that contains a list of pdb files resolved by x-ray, nmr & EM-cryo expt 
  @expmethd_input = <PDBMETH>;	close (PDBMETH);
  $expmethd_len = @expmethd_input;
  
  open (NMR_XRAY, '>NMR_Xray.csv'); {			
	$ctr_nmr_xray = 0;
	@xray =();
	@nmr =();
	print NMR_XRAY "Cluster #,NMR,XRay\n";
    for ($expmeth_line = 1; $expmeth_line < $expmethd_len; $expmeth_line++) {	
	  @pdbid_nmr_xray = split /,/,$expmethd_input[$expmeth_line];
	  if (($pdbid_nmr_xray[2]!=0) && ($pdbid_nmr_xray[3]!=0))		{# Identify pdb files generated by both NMR and X ray
		 $ctr_nmr_xray++;
		 push (@xray,$pdbid_nmr_xray[3]); push (@nmr,$pdbid_nmr_xray[2]);
		 print NMR_XRAY $ctr_nmr_xray,",",$pdbid_nmr_xray[2],",",$pdbid_nmr_xray[3];
	  }
	}
  } close (NMR_XRAY);
  $expmethd_len = $expmethd_len - 1;
  print "\nThere are $ctr_nmr_xray proteins with both NMR and X-ray structures \nout of $expmethd_len structures resolved by multiple experiments.\n";
  print "\nList of pdb files saved as \"NMR_Xray\.csv\"\n";
}

sub get_web_pdb {
  use LWP::Simple;	# Required module for getting contents of a webpage
  
  chomp ($dir_xray, $dir_nmr, $pdbid_nmr_xray[2],$pdbid_nmr_xray[3], $ext);
  $dir_xray ='xray/';  $dir_nmr ='nmr/';							# directories
  
  open (nmr_xray, 'NMR_Xray.csv');									# Open csv file that contains a list of pdb files resolved by X ray and NMR
  @nmr_xray_input = <nmr_xray>;	close (nmr_xray);
  $nmr_xray_input_len = @nmr_xray_input;
  
  $file_xray = $dir_xray.$pdbid_nmr_xray[3].$ext;					# xray directory/filename
  
  # download first 10 pdb files, # 8 nmr clusters already finished
  for ($cluster_num = 1; $cluster_num <= 2; $cluster_num++){
	@pdbid_input = split /,/,$nmr_xray_input[$cluster_num];																																														# split pdb list into NMR and X-ray
	
	# @nmr_cluster_input = split / /,$pdbid_input[1];				# split NMR(1) cluster into individual pdb ids
	#  $nmr_input_len = @nmr_cluster_input;
	#  chomp($cluster_num,$nmr_cluster_input,$nmr_input);
	#  for ($nmr_input = 0; $nmr_input < $nmr_input_len; $nmr_input++) {
	#	$file_nmr = $dir_nmr.$nmr_cluster_input[$nmr_input].$ext;	# nmr directory/filename	  
	#	print "\nSaving $nmr_cluster_input[$nmr_input] to $dir_nmr directory... ";
	#	getstore( "http://rcsb.org/pdb/download/downloadFile.do?fileFormat=pdb&compression=NO&structureId=$nmr_cluster_input[$nmr_input]","$file_$file_nmr"); 
	 #   print "Done.\n";
	 # }
	  
	  @xray_cluster_input = split / /,$pdbid_input[2];				# split xray(2) cluster into individual pdb ids
	  $xray_input_len = @xray_cluster_input;
	  chomp($cluster_num,$xray_cluster_input,$xray_input);
	  for ($xray_input = 0; $xray_input < $xray_input_len; $xray_input++) {
		$file_xray = $dir_xray.$xray_cluster_input[$xray_input].$ext;	# xray directory/filename	  
		print "\nSaving $xray_cluster_input[$xray_input] to $dir_xray directory... ";
		getstore( "http://rcsb.org/pdb/download/downloadFile.do?fileFormat=pdb&compression=NO&structureId=$xray_cluster_input[$xray_input]","$file_$file_xray"); 
	    print "Done.\n";
	  }
  }
}

sub identify_missing_residues {

print "\nInput:\t", $coordinate_file =  "$base.pdb","\t" ;				# Input PDB ID

print 
open (PDBIN, "$coordinate_file");	@pdb_input = <PDBIN>;	close (PDBIN);
  $file_len = @pdb_input;
  @prot_name = split /    /,$pdb_input[0];								# Identify protein name 
  print "$prot_name[1]\n";
  
#&check_expdata;															# Identify type of Experiment


if ($exptdta[1]=~ m/X-RAY/){  											# proceed to identification of missing residues if expt is x-ray, otherwise halt program
  @missing_res_section = ();
  for ($line_num = 0; $line_num < $file_len; $line_num++) { 			# Get the Missing Residues Section
	if ($pdb_input[$line_num] =~ m/REMARK 465/){ 	
	push (@missing_res_section, $pdb_input[$line_num]);
	}
  }
  
  for ($missing_res_len = 0; $missing_res_len < 7; $missing_res_len++) { # Remove Legend lines
	shift (@missing_res_section);
  }
  
  $missing_res_ctr = @missing_res_section;
  print "\nThere are $missing_res_ctr  missing residues in this protein.\n\n";
  
  open (MISSING, '>pdb_missing_residues.csv');{
  $line_num = 0;
  @missing_res = (); @missing_res_chain = (); @missing_res_pos = ();
  print MISSING "Residue,Chain,Position";
  print "Residue\tChain\tPosition\n";
  foreach (@missing_res_section){
  if ($missing_res_section[$line_num] =~ m/REMARK 465     /){
	s/REMARK 465     //g;s/ //g;}														    # substitute / remove REMARK
	chomp($missing_res_section[$line_num]);
	$residue = substr($missing_res_section[$line_num],0,3); push (@missing_res, $residue); 	# Get missing residues (0-3)
	$chain = substr($missing_res_section[$line_num],3,1); push (@missing_res_chain, $chain); # Get missing residues chain (4)
	$position = substr($missing_res_section[$line_num],4); push (@missing_res_pos, $position); # Get the position of missing residues
	print MISSING "\n$residue,$chain,$position";
	print "$residue\t$chain\t$position\n";
	$line_num++;
  }
  close (MISSING); }

  }
}

sub check_expdata {
  for ($line = 0; $line < $file_len; $line++) { 			
	if ($pdb_input[$line] =~ m/EXPDTA/){ 					# Identify type of Experiment
	@exptdta = split /    /,$pdb_input[$line];
		if ($exptdta[1]=~ m/X-RAY/){
			print "\nExperimental Data: ","$exptdta[1]\n";	
		} else { 
			print "\nThis is not a valid X-Ray Diffraction data.\n";	
			print "\nExperimental Data: ","$exptdta[1]\n";}
	}
	if ($pdb_input[$line] =~ m/REMARK   2 RESOLUTION/){ 	# Identify resolution
	@resoln = split /    /,$pdb_input[$line];
	}
	if ($pdb_input[$line] =~ m/REMARK 900 RELATED ID/){ 	# Identify if there are related sequences
	@rel_strc = split / /,$pdb_input[$line];
	}

  } $ext = ".pdb";
	$related_struct = $rel_strc[4].$ext;
	print "Resolution: ","$resoln[1]\n";
	print "Related structure(s): ","$rel_strc[4]\tSource: $rel_strc[9]\n";
}

sub detmn_coor_in_nmr {
  open (MISSING_RES, 'pdb_missing_residues.csv');	@missing_residues = <MISSING_RES>;	close (MISSING_RES);
	$missing_res_cnt = @missing_residues;

  open (NMR_IN, 'nmr/SAMPLE.pdb');	@nmr_input = <NMR_IN>;	close (NMR_IN);
    $nmr_input_len = @nmr_input;
 
  open (NMR_COOR, '>nmr_coordinates.txt');{
  $model_ctr =0;
  for($line_ctr=0; $line_ctr < $nmr_input_len; $line_ctr++){
	  if ($nmr_input[$line_ctr] =~ m/^MODEL/){						# Matches lines that begins with the word MODEL
		print NMR_COOR "$nmr_input[$line_ctr]";
		$model_ctr++;
	  }
	  if (($nmr_input[$line_ctr] =~ m/^ATOM/)||($nmr_input[$line_ctr] =~ m/^TER/)){						# Matches lines that begins with the word ATOM
		$missing_res_in_nmr = substr($nmr_input[$line_ctr],17,3);	# substr(expr,offset,length) 
		$missing_chain_in_nmr = substr($nmr_input[$line_ctr],21,1);
		$missing_pos_in_nmr = substr($nmr_input[$line_ctr],23,3);
		
		chomp($missing_res_in_xray,$missing_res_in_nmr,$missing_chain_in_xray,$missing_chain_in_nmr,$missing_pos_in_xray,$missing_pos_in_nmr);			
		  for ($ctr =1; $ctr <= $missing_res_cnt; $ctr++){			
			@missing_residue = split /,/,$missing_residues[$ctr];	#split missing residue list to residue[0], chain[1] and position[2]
			$missing_res_in_xray = $missing_residue[0];$missing_chain_in_xray = $missing_residue[1];$missing_pos_in_xray = $missing_residue[2];
			  if (($missing_res_in_xray==$missing_res_in_nmr)&&($missing_chain_in_xray==$missing_chain_in_nmr)&&($missing_pos_in_xray==$missing_pos_in_nmr)){
				print NMR_COOR "$nmr_input[$line_ctr]";
			  }
		  } 
	  }
	}  print "\nThere are $model_ctr models in this NMR data.\n";
	   print "\nNMR coordinates saved to \"nmr_coordinates.txt\".\n";
  } close (NMR_COOR);

  open (NMR_COOR_IN, 'nmr_coordinates.txt');	@nmr_coordinates = <NMR_COOR_IN>;	close (NMR_COOR_IN);
	$nmr_coordinates_cnt = @nmr_coordinates;
	$atom_num = $nmr_coordinates_cnt/$model_ctr;	# number of atoms in the missing residues
	$missing_pos_in_nmr = substr($nmr_input[$line_ctr],23,3);
}

sub split_nmr_models {
  print "\nInput:\t$base.pdb","\t" ;				
  mkdir $base;															# create directory named after the PDB ID

  open(IN,"<$base.pdb");@pdb_input = <IN>;$i=0;
  $line_number = 1;
	foreach $pdb_line(@pdb_input) {
	  if ($pdb_line =~/^MODEL/){ 										# find the start of each MODEL
		$end = $line_number; last;										# assign the start of the model as the end of the header
	  } $line_number++;
	} @header = @pdb_input[1..($end-2)];								# parse the content of the header section
	
	foreach $line(@pdb_input) {
	  if($line =~ /^MODEL/) {											# find the start of each MODEL
		++$i;															# pdb file counter
		$file="${base}_$i.pdb";
		open(OUT,">$base/$file");										
		chomp ($pdb_input[$_]);
		print OUT substr($pdb_input[0],0,70), "MODEL $i\n";				# write the model number into the output file
		print OUT @header;
		next}
	  if($line =~ /^ENDMDL/) {next}										# find the end of each MODEL
	  if($line =~ /^ATOM/ || $line =~ /^HETATM/) {print OUT "$line"}	# write the coordinates of each model into the output file
	}
  print "\n\nThere are $i models in this NMR ensemble."; 
  print "\n\nModels saved to $base folder as: $base\_1.pdb to $base\_$i.pdb\n";
}

sub calc_phi_psi {
$DSSP = "dssp-2.0.4-win32.exe";							# name of the dssp executable file (phi-psi predictor)

$model_ctr = "3";
$dir = "$base/"; $input = "$base\_$model_ctr.pdb"; 					
$filein = $dir.$input;
$out = "$base/$base\_$model_ctr.dssp";

if( -f $DSSP ){											# check if file exists
  print "\nInput: $input\nOutput: $base\_$model_ctr.dssp\n\n";
  @output = qx/"$DSSP  -i $filein"/ or die $?;			# run executable by the system with defined input and output to an array
  #system ("$DSSP  -i $filein -o $out") or die $?;		# run executable by the system with defined input and output to a file ($out)
}
  $output_len = @output;
  for ($line_len = 28; $line_len < $output_len; $line_len++) { 	# Get phi and psi values beginning at the dihedral angle values
	$line = $output[$line_len];
	  print $pos = substr($line,7,3), " "; 				# Get position at column 7, max of 3 characters
	  print $chain = substr($line,11,1), " "; 			# Get chain type at column 11, max of 1 character
	  print $res = substr($line,13,1), " "; 			# Get residue name at column 13, max of 1 character
	  #$pos_res_ch = $pos.$res.$chain;					# concatenate strings into one
	  print  $phi = substr($line,103,6), " "; 			# Get phi value at column 103, max of 6 characters
	  print  $psi = substr($line,109,6), "\n"; 			# Get psi value at column 109, max of 6 characters
	 #push(@{$hash{$key}}, $insert_val);				Insert an element to an array 
  }
}



sub calc_circ_variance {
$dir = "dihedral/$base";	
$file_ctr=3;

#&comb_dihed;											# combine dihedral values from several models into one file
&calc_circ_var;

sub comb_dihed {										# combine dihedral values from several models into one file
opendir(DIR, $dir); @FILES= readdir(DIR);				# open directory of files containing dihedral angles
 $file_num = @FILES;  $file_num = $file_num - 2;

 
# for ($file_ctr=1;$file_ctr<=$file_num;$file_ctr++){
 
  foreach $file (@FILES){								# read directory
    print "$file\n"; 
  } print "\nDirectory: $dir   $file_num File(s)\n";
 closedir(DIR);

 print "\n\nInput:\t", $dihed_file="$dir/$base\_$file_ctr.dhd","\n\n" ;	# Input file containing dihedral angles (phi & psi)

open (DIHEDIN, "$dihed_file");{	@dihed_input = <DIHEDIN>;	close(DIHEDIN)};

  %phi_psi_val = (							# declare hash of hashes
	 model => {
		pos_res_ch => [],
		phi => [],
		psi => [],
	},
  );
  
  $phi_psi_ctr =0;
  foreach $line (@dihed_input) { 			# Get phi and psi values
	if ($line =~ m/TORSIN/){ $phi_psi_ctr++;
	
	$pos = substr($line,13,3); 				# Get position at column 13, max of 3 characters
	$res = substr($line,7,3); 				# Get residue name at column 7, max of 3 characters
	$chain = substr($line,11,1); 			# Get chain type at column 1, max of 1 character
	$pos_res_ch = $pos.$res.$chain;			# concatenate strings into one
	$phi = substr($line,22,6); 				# Get phi value at column 22, max of 6 characters
	$psi = substr($line,29,6); 				# Get psi value at column 29, max of 6 characters
	
	#push(@{$hash{$key}}, $insert_val);		Insert an element to an array 
	push(@{$phi_psi_val{pos_res_ch}}, $pos_res_ch);
	push(@{$phi_psi_val{phi}}, $phi);
	push(@{$phi_psi_val{psi}}, $psi);
	}
  }

  	open(OUT,">>$dir/$base.dhd2");{
	# foreach (@{$phi_psi_val{pos_res_ch}}) { print OUT "$_,";} print OUT "\n";	 
	  foreach (@{$phi_psi_val{phi}}) { print OUT "$_,";} print OUT "\n";
	  foreach (@{$phi_psi_val{psi}}) { print OUT "$_,";} print OUT "\n";
	close}
}

sub calc_circ_var {

$pi = 4*atan2(1,1);							# gives the value of pi; value /180 * pi => degrees to radians
open (DIHEDOUT, "$dir/$base.dhd2");{	@dihed_out = <DIHEDOUT>;	close(DIHEDOUT)}
$dihed_out_len = @dihed_out;
$dihed_out_len = $dihed_out_len - 1; 		# exclude the last residue from calculation of circular variance

print "\nInput file: $dir/$base.dhd2\n"; 
print "\nLegend: res = amino acid residue; c = chain; var = circular variance\n";


 open (CIRC_VAR, ">$dir/$base.cv");{
	print CIRC_VAR "  res c c_var"; print CIRC_VAR "\n  === = =====\n";	
	print "\n  res c c_var"; 	print "\n  === = =====\n";

	# start $line_num at 1 to exclude the first residue from calculation of circular variance
  for ($line_num = 1;  $line_num < $dihed_out_len; $line_num++){
  
   @values = split /,/,$dihed_out[$line_num]; 

   $sum_cos_phi = cos(deg2rad($values[1])) + cos(deg2rad($values[3])) + cos(deg2rad($values[5]));	# summation of cosine phi 
   $sum_sine_phi = sin(deg2rad($values[1])) + sin(deg2rad($values[3])) + sin(deg2rad($values[5]));	# summation of sine phi 
   $sum_cos_psi = cos(deg2rad($values[2])) + cos(deg2rad($values[4])) + cos(deg2rad($values[6]));	# summation of cosine psi 
   $sum_sine_psi = sin(deg2rad($values[2])) + sin(deg2rad($values[4])) + sin(deg2rad($values[6]));	# summation of sine psi 

   $R_exp2 = 0.5*(($sum_cos_phi**2) + ($sum_sine_phi**2) + ($sum_cos_psi**2) + ($sum_sine_psi**2));	# R squared
   $R_ave = (sqrt($R_exp2))/$n;																		# R average, $n = # of models 
   $circ_var = 1 - $R_ave;																			# circular variance
   $rounded = sprintf "%.3f", $circ_var;															# round-off to 3 decimal places
	   
   $res_len = length($values[0]);
     if ($res_len==5){
		$pos2 = substr($values[0],0,1);
		$res2 = substr($values[0],1,3);
		$chain2 = substr($values[0],4,1);
     }
     if ($res_len==6){
		$pos2 = substr($values[0],0,2);
		$res2 = substr($values[0],2,3);
		$chain2 = substr($values[0],5,1);
	 }
	 if ($res_len==7){
		$pos2 = substr($values[0],0,3);
		$res2 = substr($values[0],3,3);
		$chain2 = substr($values[0],6,1);
	 }
		print CIRC_VAR "$pos2 $res2 $chain2 $rounded\n";
		print  "$pos2 $res2 $chain2 $rounded\n";
  }  close (CIRC_VAR)
  }  print "\nValues of circular variances saved to: $dir/$base.cv\n";
 }
}

sub deg2rad { 
  my $pi = 4*atan2(1,1);		# gives the value of pi
  ($_[0]/180) * $pi; 
}